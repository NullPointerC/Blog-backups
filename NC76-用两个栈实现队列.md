---
title: NC76-用两个栈实现队列
categories: [nowcoder]
tags:
  - algorithm
  - nowcoder
date: 2021-09-27 21:21:22
---

[$link$](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=188&&tqId=38552&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

<hr/>

![image-20210927212223966](https://gitee.com/cao_ziqiang/img/raw/master/20210927212224.png)

<hr/>

这里我想到的一种比较简单但是复杂度不能够满足题意的解法,保证一个栈的栈顶为队头,这就可以考虑在插入前,先将$stack1$清空,再将新插入的节点$node$添加到这个空栈中,再把另一个满栈中的元素依次$pop$出栈,并且$push$进空栈,这样就可以保证有一个栈的栈顶永远都是队头元素。

但是这样无法保证时间复杂度是因为，在每次$push$时都需要移动两遍节点，所以复杂度为$O(n)$。

```java
import java.util.Stack;

public class Solution {
    // 保证stack1栈顶为队头
    Stack<Integer> stack1 = new Stack<Integer>();
    // 做过渡用
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        while(!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }
        stack1.push(node);
        while(!stack2.isEmpty()) {
            stack1.push(stack2.pop());
        }
    }
    
    public int pop() {
        return stack1.pop();
    }
}
```

上面的解法在于维护了插入的顺序，其实没必要在一个栈中维护这个顺序，可以考虑只在一个栈中$push$。而当需要$pop$的时候，再考虑将其从一个栈转移到另一个栈中，如果另一个为空，则需要将数迁移过去，如果不为空，则直接$pop$即可，可以推出，对于需要全部迁移的次数是只占多数中的一次，所以均摊时间复杂度也可以达到$O(1)$。

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        if(stack2.isEmpty()) {
            while(!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
            return stack2.pop();
        }else{
            return stack2.pop();
        }
    }
}
```

