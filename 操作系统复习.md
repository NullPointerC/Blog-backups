---
title: 操作系统复习
categories:
  - OS
tags:
  - 计算机基础
  - backend
abbrlink: cd647b6c
date: 2021-06-27 11:50:18
---

前言

<pre>
    本次复习基于《操作系统原理与实践》-朱明华
    视频看的是操作系统(哈工大李治军老师)的视频，王道考研操作系统的资料以及学习了B站CodeSheep的一次知识梳理
</pre>


## 一.什么是操作系统?

**是计算机硬件和应用之间的一层软件**

方便我们使用硬件，如使用显存...

高效的使用硬件，如开多个终端(窗口)

操作系统介于计算机硬件和应用软件之间,向上对硬件进行驱动和管理,向下管理软件的运行,提供各种对硬件和软件功能的请求服务。

**操作系统是计算机系统中的一个系统软件，它统一管理计算机的软硬件资源和控制程序的执行，提供人机交互的接口和界面。**

PS:这里听到老师说斯坦福,CMU的学生要做那么难的实验,从板子到操作系统,tql,算了,这些名校的学生确实强,还是先自己把理论学好再说吧

常用术语总结:

| 名词                                         | 概念                                                         |
| -------------------------------------------- | :----------------------------------------------------------- |
| <font color ="blue">PCB</font>               | 进程控制块（PCB Process Control Block）,系统中存放、管理和控制进程信息的数据结构称为 |
| <font color ="blue">TCB</font>               | 线程控制块                                                   |
| <font color ="blue">FCB</font>               | 文件控制块                                                   |
| <font color ="blue">PID</font>               | 进程ID(Process ID)                                           |
| <font color ="blue">PSW</font>               | 程序状态字寄存器，用于存放PC、IR等的信息                     |
| <font color ="blue">PC</font>                | 程序计数器，存放下一条指令地址                               |
| <font color ="blue">IR</font>                | 指令寄存器，存放到当前进行的指令                             |
| <font color ="blue">半双工</font>            | 半双工和全双工是计算机网络中的概念，意思是通讯同一时间只允许一方发送数据(对讲机) |
| <font color ="blue">全双工</font>            | 通信允许两方向上同时传输数据(电话)                           |
| <font color ="blue">P操作</font>             | 来自荷兰语proveren，代表wait原语，通常使用P(S)代替wait(S)    |
| <font color ="blue">V操作</font>             | 来自荷兰语verhogen，代表原语signal,通常使用V(S)代替signal(S) |
| <font color ="blue">用户态</font>            | 一般的操作系统对执行权限进行分级，分别为用保护态和内核态。用户态相较于内核态有较低的执行权限，很多操作是不被操作系统允许的，从而保证操作系统和计算机的安全。 |
| <font color ="blue">内核态</font>            | 内核态相当于一个介于硬件与应用之间的层，可以进行硬件的调度、使用，可以执行任何cpu指令，也可以引用任何内存地址，包括外围设备, 例如硬盘, 网卡，权限等级最高。 |
| <font color ="blue">用户态内核态切换</font>  | 三种情况下，用户态会转换到内核态，`系统调用、程序异常(例如/0，内存资源耗尽等)、来自外围设备的中断` |
| <font color ="blue">系统调用/程序接口</font> | 用户程序通过系统调用的方式才能对硬件进行使用，或者说操作系统将使用硬件的接口提供给用户程序 |
| <font color ="blue">中断</font>              | 中断是操作系统内核程序夺取cpu的唯一途径，或者说用户程序调用内核代码的唯一途径，因为在一般情况下，操作系统会将cpu使用权交给应用程序。 |

## 二.操作系统接口

命令:命令是一个用C语言编写的程序

图形按钮:图形按钮也是一个包括画图的C程序,包括了一套消息框架程序和消息处理程序

都是通过操作系统提供**一些重要的函数**,被称为**操作系统接口**,**接口表现为函数调用**,又由系统提供,所以称为系统调度

## 三.操作系统历史

手工操作阶段	->	批处理操作系统	->	多道批处理操作系统	->	分时、实时和通用操作系统	->	现代操作系统

## 四.进程

CPU的工作原理:**自动的取指-执行**

只要设置好PC初值,CPU就能自动从地址总线中取指-执行

**一个CPU上交替的执行多个程序:并发**

**为了充分利用CPU**,因为**I/O指令和计算指令速度不同**,所以我们需要启动多个程序,交替执行

<hr/>

这里就引出了运行的程序和静态的程序两个不同的概念,运行的程序需要记录运行时刻以及运行的信息,**启动了的程序就是进程。**

进程有开始,有结束,并且执行过程中会走走停停,需要记录ax,bx,信息都需要记录在进程控制块PCB中。

多进程的组织：PCB+状态+队列

<hr/>

进程控制相关的原语：`创建、终止、阻塞、唤醒、切换`。也就是说我们通过原语进行进程控制，原语的执行具有原子性，不允许被中断，原语的实现可以通过“关中断指令”和“开中断指令”实现。

进程状态：`运行态，就绪态，阻塞态`

进程状态图如下：

![Snipaste_2021-06-28_10-52-03](https://gitee.com/cao_ziqiang/img/raw/master/20210628105323.png)

进程状态转换的条件：

运行 -> 阻塞  等待I/O或事件完成

运行 -> 就绪 进程的CPU时间片用完

就绪 -> 运行 获得了CPU的时间片

阻塞 -> 就绪 I/O或事件完成



交替的三个部分：队列操作+调度+切换

**多个程序切换**这时又引出了**PC地址跳转**的过程(**Yield**),由于程序运行时切换到了其他程序,前一个程序的信息我们也需要保存下来,所以我们需要使用栈来实现这个过程 。

这时，我们使用一个栈 + Yield将会造成以下混乱

![image-20210628193830907](https://gitee.com/cao_ziqiang/img/raw/master/20210628193831.png)

无法让B顺利地回到A，因为当B执行Yeild后返回204，然后再回到D，依次返回304，404

所以引入了使用两个栈 + 两个用户TCB

![image-20210628194144318](https://gitee.com/cao_ziqiang/img/raw/master/20210628194144.png)

Yield()找到下一个TCB	→	找到新的栈	→	切到新的栈

但此时只能做到用户的多个程序之间的切换，所以又引入了内核栈的切换

![1](https://gitee.com/cao_ziqiang/img/raw/master/20210628195343.png)



## 五.线程

**进程 = 资源+指令执行序列**

由于进程切换需要将资源和指令都进行切换，而资源切换往往涉及磁盘I/O，打印机这种比较慢的操作，于是我们考虑能否将资源和指令执行分开，使用同一个资源和多个指令执行序列。

这时就引入了线程的概念，**线程保留了并发的优点，避免了进程切换的代价**

![image-20210628111738978](https://gitee.com/cao_ziqiang/img/raw/master/20210628111739.png)

实质就是映射表不变而PC指针变化

例如在一个浏览器中

一个线程用于从服务器接受数据；

一个线程用来显示文本；

一个线程用来处理图片（解压缩）；

一个线程用来显示图片；

后面讲到用户级线程和内核级线程的区别，李治军老师结合汇编讲的，没学过汇编，没学过计组，太痛苦了。。。其实老师讲得挺好的，但是自己太菜了，很多重要的没听懂

这里讲讲自己能够听得懂的把：

用户级线程是通过中断INT进入的内核级线程，然后balabala。。。

用户级线程和内核级线程各自维护一套栈系统，用于存储各自不同的信息；

然后push用户级线程的信息进入内核级线程的栈中；

然后进行调度schedule，最后中断出口返回用户栈，如果这中间出现了一些意外，如I/O或者时间片用光，则切换到其他的内核级线程，最后还是返回用户级线程；

## 六.CPU调度策略

调度的产生是因为系统资源有限，没办法同时处理所有进程，需要特定的规则分配执行顺序，从而有了调度

总原则： 系统专注于任务执行， 又能合理搭配任务

First Come, First Served（FCFS）：先来先服务（实现简单，保证了公平，但是周转时间可能比较长）

SJF：短作业优先（可以缩短作业周转时间）

RR：时间片轮转调度（同样保障了公平，但是时间片大，响应时间太长，时间片小：吞吐量小）

操作系统调度层次分为三类：高级调度、中级调度、低级调度。

<font color= "orange">高级调度</font>：从外存的后备作业中挑选一个(多个)，建立相应的PCB，获得竞争处理的权力。

后面会讲到的虚拟内存技术出现后，为了提高系统的利用率和吞吐量，会将暂时等待的进程挂起到外存。

<font color= "orange">中级调度</font>：能够决定哪个被挂起的进程重新回到内存中。

<font color= "orange">低级调度</font>:从就绪队列中选取一个进程，使其能够被CPU处理。

三种调度方式的频率从低到高。

<hr/>

调度算法评价指标:

`CPU利用率` = 忙碌的时间/总时间

`系统吞吐量` = 总共完成了多少道作业/总共花了多少时间  (简单理解就是一个完成作业的速度指标)

`周转时间 `= 作业完成时间– 作业提交时间

`平均周转时间` = 各作业周转时间之和/作业数

`带权周转时间` = (作业完成时间– 作业提交时间)/作业实际运行的时间,这项指标一定是大于等于1的，越接近一则越好

`平均带权周转时间` = 各作业带权周转时间之和/作业数

`等待时间`，指进程/作业处于等待处理机状态时间之和

`响应时间`，指从用户提交请求到首次产生响应所用的时间。例如键盘事件响应时间，鼠标点击响应时间

## 七.进程同步与信号量

进程之间往往需要合作，多个进程共同完成一个任务

进程合作需要有序地推进，如果两个进程之间，一个进程需要某个信号在等待另一个进程时，这时成为进程同步，需要让进程走走停停来保证多进程合作的合理有序

这时我们再引入生产者-消费者问题，若存在两个生产者P1,P2和一个消费者C。

![image-20210628213241296](https://gitee.com/cao_ziqiang/img/raw/master/20210628213241.png)

（1）当缓冲区满以后生产者P1生产一个item放入，会sleep;

（2）又一个生产者P2生产一个item放入，会sleep;

（3）消费者C执行1次循环，counter==BUFFER_SIZE-1，发信号给P1,P1 wakeup

（4）消费者C再执行1次循环，counter==BUFFER_SIZE-2，P2不能被唤醒

这时我们发现不只是等待信号，发信号，还应该能记录一些信息，并根据这个信息来唤醒（睡眠）进程

信号量：1965年，由荷兰学者Dijkstra提出的一种特殊整型变量，量用来记录，信号用来sleep和wakeup

```c
struct semaphore
{
	int value;//记录资源个数
    PCB *queue;//记录等待在该信号量上的进程
}
/*P操作原语*/
P(semaphore s);//消费资源
/*V操作原语*/
V(semaphore s);//产生资源
P(semaphore s)
{
    /*资源个数减1*/
    s.value--;
    if(s.value < 0){
        /*进程睡眠*/
        sleep(s.queue);
    }
}
V(semaphore s)
{
    /*资源个数加1*/
    s.value++;
    if(s.value <= 0){
        /*进程唤醒*/
        wakeup(s.queue);
    }
}
```

用信号量解生产者-消费者问题

```c
int fd = open("buffer.txt");
write(fd,0,sizeof(int));//写in
write(fd,0,sizeof(int));//写out
semaphore full = 0;
semaphore empty = BUFFER_SIZE;
semaphore mutex = 1;//互斥信号量

Producer(item) {
	P(empty);
	P(mutex);
	//读入in;将item写入到in的位置上;
	V(mutex);
	V(full);
}

Consumer() {
    P(full);
    P(mutex);
    //读入out；从文件中的out位置读出到item；打印item;
    V(mutex);
    V(empty);
}
```

信号量与临界区保护 

解决竞争条件的直观想法,给共享变量加锁,一段代码一次只允许一个进程进入(原子性操作)

临界区:一次只允许一个进程进入的该进程的那一段代码

临界区的保护原则:

(1)互斥进入:如果一个进程在临界区中执行，则其他进程不允许进入,这些进程间的约束关系称为互斥,这就保证了是临界区;

(2)有空让进:若干进程要求进入空闲临界区时,应尽快使一进程进入临界区;

(3)有限等待:从进程发出进入请求到允许进入,不能无限等待;

进入临界区的一个尝试 - 轮换法

![image-20210629105541442](https://gitee.com/cao_ziqiang/img/raw/master/20210629105541.png)

死锁:多个进程由于互相等待对方持有的资源而造成的谁都无法执行的情况

死锁的成因:

(1).资源互斥使用,一旦占有别人无法使用

(2).进程占有一些资源,又不释放,再去申请其他资源

(3).各自占有的资源和互相申请的资源形成了环路等待

死锁的4个必要条件:

(1).互斥使用

对必须互斥使用的资源的争抢才会导致死锁

(2).不可抢占

进程所获得的资源未使用完之前，不能被其他进程强行夺走，只能主动释放

(3).请求和保持

进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己有的资源保持不放。<font color="blue">就像很窄的桥，两个人都要去对面，但谁又都无法让出位置来</font>

(4).循环等待

存在一种进程资源的循环等待，链中的每一个进程已获得的资源同时被下一个进程所请求。<font color="blue">想象有一个闭环，闭环上每个人都需要下一个人手上的某个资源，那么所有人都没办法满足</font>

死锁的处理方法

(1).死锁预防

破坏死锁出现的必要条件;

在进程执行之前,一次性申请所有需要的资源,不会占有资源再去申请其他资源,但这样需要预知未来,对于编程实现是十分困难的,并且许多资源分配很长时间后也不会使用到,资源利用率低

对资源类型进行排序.资源申请必须按序进行,不会出现环路等待,但是仍然会造成资源浪费

(2).死锁避免

检测每个资源请求,如果造成死锁就拒绝;

如果系统中的所有进程存在一个可完成的执行序列P1,P2...Pn,则称系统处于安全状态 

(3).死锁检测+恢复

检测到死锁出现时,让一些进程回滚,让出资源;

检测方法通过死锁检测算法，下面以图的方式说明

![image-20210630200717448](https://gitee.com/cao_ziqiang/img/raw/master/20210630200717.png)

能够消除所有边，就不会发生死锁如下图

![image-20210630200749913](https://gitee.com/cao_ziqiang/img/raw/master/20210630200750.png)

不能消除所有边就会发生死锁

![image-20210630200808918](https://gitee.com/cao_ziqiang/img/raw/master/20210630200809.png)



(4).死锁忽略

就好像没有出现死锁一样,死锁概率本不高，就算出现了也只是局部的死锁，直接不管反而能提高资源利用率与整体运行的速度，也有个好听的名字叫鸵鸟算法，这样性能会提升不少，大部分操作系统也采用死锁忽略的策略。

## 八.内存使用与分段

内存使用:将程序放到内存中,PC指向开始地址

可执行文件需要放在内存中才可以运行，程序中的指令是逻辑地址，而内存中的地址是物理地址。如何将逻辑地址转为物理地址？

重定位:修改程序中的地址(是相对地址),可以在编译时完成,也可以在载入时完成

1. 绝对装入

下图为可执行文件指令。

![image-20210630201045323](https://gitee.com/cao_ziqiang/img/raw/master/20210630201045.png)

假如0-100的地址已经被占用，系统知道装入模块要从地址为100 的地方开始存放，编译时就将指令的绝对地址载入了可执行文件，即

![image-20210630201059028](https://gitee.com/cao_ziqiang/img/raw/master/20210630201059.png)

2. 静态重定位

编译、链接后的装入模块的地址都是从0开始的，即可执行文件指令地址不变，在装入内存时，逻辑地址全部+100，装入内存中。所以作业一旦装入就没办法再更改、申请内存空间。

3. 动态重定位

又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到**程序真正要执行时才进行**。

**这种方式需要一个重定位寄存器的支持**，寄存器记录了初始进入的的地址即100，在程序运行时，会动态的将指令中的逻辑地址增加上初始地址。



![image-20210630201136798](https://gitee.com/cao_ziqiang/img/raw/master/20210630201136.png)

程序由若干部分(段)组成,每个段有各自的特点,用途:代码段只读,代码/数据段不会动态增长

这样也符合用户的观点,用户可以独立考虑每个段,通过段号+段内偏移来定位具体指令

## 九.内存分区域分页

引入分页:解决内存分区导致的内存效率的问题

![image-20210630201348461](https://gitee.com/cao_ziqiang/img/raw/master/20210630201348.png)

<font color="orange">页框</font>: 每个分区就是一个“页框”（页框=页帧=内存块=物理块=物理页面）

<font color="orange">页面</font>:将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面”

> 页框不能太大，否则可能产生过大的内部碎片导致浪费。

页框和页面总是记混，技巧其实很简单只要记住<font color="blue">页面放在页框中</font>，就再也不会记混了。



<font color="orange">页表</font>:操作系统要为每个进程建立一张页表。页表通常存在PCB,这里概念不清的话可能会有疑惑为什么PCB中会有页表，仔细阅读前面的部分，PCB中不光存放进程，还存放着进程信息、PID、IO情况等多个内容。

页表记录进程页面和实际存放的内存块之间的映射关系

![image-20210630201438680](https://gitee.com/cao_ziqiang/img/raw/master/20210630201438.png)

使用分段式存储,无论是哪种分区方法,总会产生内存碎片,久而久之,就会造成总空闲空间>need,但是没有一个空闲分区>need ,那些零碎的空间称为内存碎片;

如果我们将空闲分区合并,需要移动1个段(复制内容):内存紧缩。内存紧缩需要花费大量时间,如果复制速度为1M/s,则1G内存的紧缩时间为1000s≈17min。

所以我们针对每个段内存的请求,系统一页一页的分配给这个段。

多级页表与快表：

为了提高内存空间的利用率，页应该小，但是页小了页表就大了

如果我们是4G（2^ 32)的内存空间，页面尺寸为4K，那么将会有2^32 / 2 ^ 12 = 2^20个页面

2^20个页表项都得放在内存中，需要4M得内存，系统中若并发运行10个进程，则需要40M内存

但是大部分逻辑地址根本不会用到。

<font color="orange">快表TLB</font>：又称联想寄存器，是访问速度比内存快很多的高速缓存。

![image-20210630201755671](https://gitee.com/cao_ziqiang/img/raw/master/20210630201755.png)

快表为什么速度快：直接从快表中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。

慢表则要在多级页表中找到对应的页表，再从相应的页号中取出内存块号。

<font color="blue">就像看一本书，快表放了书签，而慢表则要慢慢找上次看到了哪</font>

> 局部性原理：
>
> 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）
> 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）

多级页表:

为什么要有多级页表

> 根据局部性原理，进程某个时间段内只需要访问几个页面就可以正常运行了，没必要让整个页面都在内存中常驻。同时，过大的页表还会占用很多页框，也就是内存空间。

![image-20210630204246057](https://gitee.com/cao_ziqiang/img/raw/master/20210630204246.png)

当整个页表被分为多个页表，在内存中只需要放入有需求的页表，从而提高效率，节省空间。

<hr/>

段、页同时存在：段面向用户/页面向硬件

段、页同时存在：重定位和地址翻译(虚拟内存中的逻辑地址->物理内存中的物理地址)

段号+偏移（逻辑地址）	->	页号+偏移（虚拟地址）	->	物理页号+偏移（物理地址）

![image-20210630204440266](https://gitee.com/cao_ziqiang/img/raw/master/20210630204440.png)



## 十.内存换入与换出

请求分页管理：

> 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存

<font color="orange">缺页中断</font>： 在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。



缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。如果内存中没有空闲块，则由**页面置换算法**选择一个页面淘汰，同时要注意，若某个页面被换出外存，则**快表**中的相应表项也要删除，否则可能访问错误的页面



**理解缺页**，缺页就像货架上缺少了商品，需要从仓库里调取商品，就先暂停这个货架的销售，等商品调取完毕再重新出售。

<hr/>

置换算法的评价指标是：缺页的次数，某种算法让缺页次数最低，调度效率最高，那就是最优的算法

1. 最佳置换算法

每次淘汰的页面都是以后永久不用或最长时间不使用的页面，保证最低的缺页率。**显然，这种需要预测未来的算法不可能实现。**

2. 先进先出算法FIFO

缺页时，淘汰最早进入的页面。算法简单，但局限性也明显，例如某些经常使用的页面一直被换进换出，和使用频率低的页面有相同的被换出的机会。

3. 最近最久未使用置换算法LRU

每次淘汰的页面都是最近最久未使用的页面。需要在页面中添加一个记录项，记录上次被访问以来经历的时间t，当需要淘汰页面时，选择时间t最大的淘汰，也就是最久未使用的淘汰。**算法设计虽好，但开销很大，实现困难。**

4. <font color="blue">时钟置换算法</font>

时钟置换算法也可以称为最近未使用算法。**是一种性能和开销均衡的算法。**

简单的时钟算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，**再进行第二轮扫描**（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)

如下图。

![image-20210630204606533](https://gitee.com/cao_ziqiang/img/raw/master/20210630204606.png)

问题：缺页很少，访问位都是一，那么扫描了一轮进行第二次扫描，就相当于FIFO算法，为了改进这种情况，提出了下面的算法。

改进版的时钟算法(有很多改进方式，这里只是一种)：如果把页面看成钟表，原来的慢指针相当于`时针`，现在添加一个`快指针`，相当于`分针`，分针扫描要比时针快，如果一个页面在一定时间限制内没有访问，就设访问位为0，缺页时直接换出。



## 十一.磁盘与文件

文件可以分为两类：

> 1. <font color="orange">无结构文件</font>
>
> 文件内部数据就是一系列二进制流或字符流。最典型的就是txt文件。
>
> 2. <font color="orange">有结构文件</font>
>
> 由一组相似的记录组成，又称记录式文件。典型的excel表、数据库表等。

有结构文件的逻辑结构又分`顺序文件`、`索引文件`、`索引顺序文件`，注意逻辑结构是展示给用户的，是文件的组织形式，例如是一张顺序存储的excel表格，还是一张excel索引表加上excel顺序表，还是多级索引加顺序，而不是在计算机上的存储方式。

<font color="orange">顺序文件</font>：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。

> 顺序存储即逻辑相邻的文件物理上也相邻，链式存储即在末尾添加新的文件。

记录的类型又分为可变长和不可变长记录：

![image-20210630204751346](https://gitee.com/cao_ziqiang/img/raw/master/20210630204751.png)

**问题**：对于可变长记录文件，要找到第i 个记录，必须先顺序第查找前 i - 1 个记录，但是很多应用场景中又必须使用可变长记录。如何解决这个问题？

之后提出了<font color="orange">索引文件</font>:简单而言就是引入了索引表的文件。索引表本身是顺序文件，即索引表顺序存储在一起。

![image-20210630204832435](https://gitee.com/cao_ziqiang/img/raw/master/20210630204832.png)

**问题**：：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。

<font color="orange">索引顺序文件</font>：索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项，索引表项的地址直接指向顺序文件所在区域，再顺序查找到所需的文件，从而节省了很大的空间。(例如我们可以通过An Qi找到An Kang、An Jie等，而不用在索引表中存放这么多信息。另外索引项之间不需要有按照逻辑关系排列)

![image-20210630204847116](https://gitee.com/cao_ziqiang/img/raw/master/20210630204847.png)

<font color="orange">多级索引顺序文件</font>：在索引顺序文件的基础上再增加层次深度，可以减少查找的次数(顺序查找范围缩小了)

![image-20210630204918466](https://gitee.com/cao_ziqiang/img/raw/master/20210630204918.png)

<hr/>

目录:

文件目录可以分为：`单级目录结构`、`两级目录结构`、`多级目录结构(树形目录结构)`

<font color="orange">单极目录结构</font>：顾名思义，所有的文件放在一个目录中，类似于一个仓库把所有文件不加整理的堆放在一起，显然效率会很低下。

<font color="orange">两级目录结构</font>:主要分为主文件目录和用户文件目录。类似于仓库中加了几个员工货架，不同员工的货物放在不同货架，但在一个货架中文件还是采用堆砌式的存储。

![image-20210630204956220](https://gitee.com/cao_ziqiang/img/raw/master/20210630204956.png)

<font color="orange">多级目录结构</font>，又称树形目录结构:我们当前主流操作系统都是多级目录结构，简而言之就是文件目录可以一级一级的延申，从而文件更有条理。

FCB(文件控制块)，首先来看一张图，如果文件目录都以这种表的形式进行信息查找，会大大降低运行效率，增加系统负担。

![image-20210630205014331](https://gitee.com/cao_ziqiang/img/raw/master/20210630205014.png)

<hr/>

![image-20210630205151281](https://gitee.com/cao_ziqiang/img/raw/master/20210630205151.png)

磁道：每一圈就是一个磁道，最内侧磁道面积最小，所以数据密度最大

扇区：磁道被划分为小的磁盘块

>  一个`盘片`可能有两个`盘面`;每个盘面对应一个`磁头`；所有磁头连在一起，共进退；每个盘面的相对位置的磁道组成`柱面`

![image-20210630205219788](https://gitee.com/cao_ziqiang/img/raw/master/20210630205221.png)

<hr/>

磁盘调度算法要解决的核心问题就是**寻道时间**，即移动磁头的时间，而其他的启动时间、传输时间都很迅速，不是最主要的时间消耗。

这里讲三种算法：

1. 先来先服务FCFS

根据进程请求房屋内磁盘的现后顺序进行调度。符合惯性思维，但在很多时候，效果很差。

![image-20210630205251546](https://gitee.com/cao_ziqiang/img/raw/master/20210630205251.png)

2. 最短寻找时间优先(学过数据结构与算法的话，核心思想就是贪心算法)，该算法会优先处理与当前磁头最近的磁道的需求。

那么很可能磁头就会如图所示的移动，也会存在饥饿问题：磁头只在一个小区域移动，而不能满足需要远距离移动的需求。例如不断有18->38，38->18的需求，那磁头就不会执行18->150的请求，从而产生饥饿。

![image-20200929112336910](https://gitee.com/cao_ziqiang/img/raw/master/20210630205324.png)

3. 扫描算法

核心思想，只有磁头移动到最外侧磁道的时候才能往内侧移动，移动到最内侧的时候才能向外侧移动。

这样就不会产生饥饿问题。

![image-20200929112735419](https://gitee.com/cao_ziqiang/img/raw/master/20210630205307.png)

<hr/>

## 十二.I/O设备



I/O就是输入输出，I/O设备就是可以将数据输入到计算机或将计算机数据输出的设备，`常见的`：鼠标、键盘、音响、显示器、打印机、话筒、摄像头等等。

<font color="orange">I/O控制器</font>:CPU无法直接控制I/O设备，需要一个电子部件去充当中间人，这个部件就是I/O控制器，CPU控制I/O控制器，I/O控制器控制I/O设备。

> 假如我们的CPU能够控制I/O设备，那不同的厂商、不同型号的设备，都要对应进行编码，显然是不切实际的，所以CPU要采用通用调度方式调度I/O设备从而需要I/O控制器。



**I/O控制器的组成**

![image-20200929120526880](https://gitee.com/cao_ziqiang/img/raw/master/20210630205412.png)

