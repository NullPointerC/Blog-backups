---
title: Spring-4-AOP
date: 2021-09-03 21:51:57
categories: FrameWork
tags: [FrameWork,backend,Spring,Java]

---

## AOP

Aspect Oriented Programming面向切面编程

AOP的做法是将通用的、与业务无关的功能抽象封装成为切面类；

切面可以配置在目标方法的执行前、后，作到即插即用；

**切面的目的是不修改源码的情况下，对程序的行为作扩展。**

## AspectJ

AspectJ是eclipse提供的一种基于Java平台的面向切面编程的语言；

Spring AOP使用AspectJWeaver实现类与方法的匹配；

Spring AOP利用代理模式来实现对象运行时的功能扩展；

## 几个重要概念

| 注解                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| AspectJ             | 切面，具体的可插拔的组件功能类，实质上还是一个类，通常由一个切面来实现一个通用功能 |
| Target Class/Method | 目标类、目标方法，指要真正执行与业务相关的方法               |
| PointCut            | 切入点，使用execution表达式来说明切面要作用在系统的哪些类上  |
| JoinPoint           | 连接点，切面运行过程中时包含了目标类、方法元数据的对象       |
| Advice              | 通知，说明具体的切面的执行时机，Spring包含了五种不同类型的通知 |

## 通知类型

| 注解                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| Before Advice          | 前置通知，目标方法运行前执行                                 |
| After Returning Advice | 返回后通知，目标方法返回数据后执行                           |
| After Throwing Advice  | 异常通知，目标方法抛出异常后执行                             |
| After Advice           | 后置通知，目标方法运行后执行                                 |
| Around Advice          | 最强大的通知，可以自定义通知执行时机，可决定目标方法是否运行 |

## 注解配置AOP

1. 在切面类上添加@Component注解标记当前类为一个组件，被IOC容器管理；
2. 添加@Aspect说明当前类是一个切面类；
3. 在切面方法上添加切面方法的通知类型，如@Around环绕通知等，并配置切入点表达式；

## 代理模式

代理模式指**通过代理对象对原对象实现功能的扩展**

Spring AOP的底层实现原理。Spring基于代理模式实现功能的动态扩展；

如果目标类拥有接口，通过JDK动态代理实现功能扩展；

如果没有接口，通过CGLib组件实现功能扩展；

### 静态代理

![image-20210904130732267](https://gitee.com/cao_ziqiang/img/raw/master/20210904130732.png)

通过代理和实现类实现同一个接口，在代理类中持有实现类的实例，并扩展要实现的方法，这种方式成为静态代理；

静态代理需要手动创建代理类，如果系统功能较多，每一实现类都有一个代理类，会使得类数量庞大；

### 动态代理

可以利用反射机制根据接口的结构自动生成代理类；

1. 创建代理增强类来实现JDK提供的InvocationHandler接口，在增强类中需要持有接口实现目标类的实例；
2. 增强类在需要实现的invoke方法中对目标方法进行增强；
3. 使用Proxy.newProxyInstance方法创建代理类，这是JDK提供的方法，会根据接口自动创建它的代理类；
4. 获得代理类时，需要传入3个参数，分别是类加载器，目标类要实现的接口，以及InvocationHandler的实现类；
5. 获取代理类后，再调用被代理类增强了的方法即可；

JDK的动态代理虽然很灵活，但是却有一个前提，必须要实现接口才可以运行，如果没有实现接口，使用反射将会报错；

### CGLIB

在实际生活中，大量的类都没有接口，不能使用JDK动态代理方式来实现功能的扩展，这时可以使用CGLIB组件实现功能的扩展；

CGLIB是运行时字节码增强技术，也是Spring AOP扩展无接口类的底层技术，它会在代码运行时，自动生成目标继承类字节码的方式进行行为的扩展；

![image-20210904133757667](https://gitee.com/cao_ziqiang/img/raw/master/20210904133757.png)

Spring 会根据代理类有没有实现接口来选择代理方式，如果目标类实现了接口，就会使用JDK动态代理，如果目标类没有实现接口，那么使用CGLib对目标类进行增强；

