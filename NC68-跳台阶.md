---
title: NC68-跳台阶
categories: [nowcoder]
tags:
  - algorithm
  - nowcoder
date: 2021-09-27 21:44:39
---

[$link$](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&&tqId=38622&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

<hr/>

![image-20210927214524429](https://gitee.com/cao_ziqiang/img/raw/master/20210927214524.png)

<hr/>

比较简单的动态规划，一趟遍历即可，$dp[i] = dp[i-1]+dp[i-2]$，发现当前的值之和前两个有关，还可以使用滚动数组节省空间。

```java
public class Solution {
    public int jumpFloor(int target) {
        if (target == 1 || target == 2) {
            return target;
        }
        int curr = 2;
        int prev = 1;
        for(int i = 3; i <= target; i++) {
            int temp = curr + prev;
            prev = curr;
            curr = temp;
        }
        return curr;
    }
}
```

<hr/>

还可以追求更快的矩阵快速幂：

```java
public class Solution {
    public int jumpFloor(int target) {
        // 斐波那契矩阵
        int[][] fib = new int[][] {
            new int[] { 1, 1 },
            new int[] { 1, 0 },
        };
        fib = QuickPow(fib, target - 1);
        return fib[0][0] + fib[0][1];
    }
    static int[][] QuickPow(int[][] a, int pow) {
        // 单位矩阵
        int[][] c = new int[][] {
            new int[] { 1, 0 },
            new int[] { 0, 1 },
        };
        // 快速幂
        while (pow > 0) {
            if ((pow & 1) == 1) c = Mul(c, a);
            a = Mul(a, a);
            pow >>= 1;
        }
        return c;
    }
    // 2阶矩阵乘法
    static int[][] Mul(int[][] a, int[][] b) {
        int[][] c = new int[][] {
            new int[2],
            new int[2],
        };
        int n = a.length;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                for (int k = 0; k < n; ++k) {
                    c[i][j] += a[i][k] * b[k][j];
                }
            }
        }
        return c;
    }
}
```

